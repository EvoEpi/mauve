<?xml encoding="UTF-8"?>


<!ELEMENT configuration (identifier*, module*, load*, start*, read*)>

<!-- defines a Java class. Used in several places -->
<!ELEMENT class (#PCDATA) >               

<!-- defines a module name -->
<!ELEMENT name (#PCDATA) >        
        
<!--
        Identifier:- This defines an indentifier for a module. There
        are two ways of doing this, which offer a nice comprimise
        between type safety within Java and genericity outside of it. 

        These two types are
              1) Enumeration. This is an identifier which extends
                 uk.ac.man.bioinf.util.AbstractEnumeration. This
                 should also implement ModuleIdentifier, and all the
                 elements of this class should each identify a single
                 module. Although it is not required it is recommended
                 Enumerations of this type actually extend from
                 uk.ac.man.bioinf.module.AbstractEnumeratedIdentifier.
                 This class ensures (or will do when its written!
                 PENDING:- PL) that the module name returned by an
                 object is the same as the variable name which holds
                 a reference to that object. This should ease
                 debugging.
                
              2) Generic. These are identifiers specified by the class
                 uk.ac.man.bioinf.module.GenericIdentifier, where both
                 the module name, and the class name is defined within
                 the XML. Instances of this class must be obtained
                 from the GenericIdentifier.resolveIdentifier( String )
                 within Java which at least has the advantage of being
                 fail-fast if not type safe.    
-->
<!ELEMENT identifier (enumeration|generic)>

<!--
        There are two types of modules, which are those
        defined by classes and those defined by interfaces. For those
        defined by interfaces there should also be a module which
        implements this interface, and will provide the object that is
        actually returned when the interface module is requested.
        PENDING:- PL. It would be possible to require that a concrete
        module be specified when the interface is defined but Ive
        decided not to. The idea is that you might want to define
        modules in one file and the implementation in another. 
-->
<!ATTLIST identifier  concrete (true|false) 'true'>         

<!ELEMENT enumeration (class)>
<!ELEMENT generic (class,name)>


<!-- 
        This tag is for module configuration. This bit is fairly open
        at the moment. 
-->
<!ELEMENT module (name, provide?,config)>

<!-- 
        This is a module which is providing the concrete
        implementation for an interface module. 
-->
<!ELEMENT provide (name)>


<!-- 
        This is the configuration for this module. This bit is totally
        open at the moment. Eventually it should several tags which
        map to various data structures that I might want to use as
        configuration. Also I havent worked out what to do yet for
        interfaces modules. Should I just add the configurations
        together or what?
-->     
<!ELEMENT config (properties?,tree?)>
        
<!--
        What to do with this config.
        replace - replace any existing configuration for this module
        add     - add to any existing configuration. Note that the properties
        configuration will still overwrite any other property with the same name
-->
<!ATTLIST config mode (replace|add) 'add'>


<!--
        A properties list
-->
<!ELEMENT properties (param+)>
<!ELEMENT param ((paramname, (value|name))+)>
<!ELEMENT paramname (#PCDATA)>
<!ELEMENT value (#PCDATA)>

<!--  
        A tree structure
-->
<!ELEMENT tree (node*)>
<!ELEMENT node ((value|name), node*)>
        
     
<!--  
        Actually load an instance of a module at this point
-->
<!ELEMENT load (name)>

<!--
        Start an instance of a module at this point
-->
<!ELEMENT start (name)>

<!--     
        Read another XML file. I think that this should leave fairly
        open how the file is specified, and where it is looked for.
-->     
<!ELEMENT read (#PCDATA)>

<!-- 
        If true and the file is not found then an error will be thrown, 
        otherwise it will be silently ignored
-->
<!ATTLIST read required (true|false) 'true'>         


